{-# LANGUAGE OverloadedStrings  #-}
{-# LANGUAGE RecordWildCards    #-}
{-# LANGUAGE TemplateHaskell    #-}
{-# OPTIONS_GHC -Wall #-}
module Codec.Xlsx.SharedStringTable (
    -- * Main types
    SharedStringTable(..)
  , StringItem(..)
  , sstParse
  , sstConstruct
  , sstLookupText
  , sstLookupRich
    -- * Lenses
    -- ** SharedStringTable
  , sharedStringTable
  ) where

import Control.Lens
import Control.Monad
import Data.IntMap (IntMap)
import Data.Maybe (mapMaybe)
import Data.Text (Text)
import Data.Vector (Vector)
import Numeric.Search.Range (searchFromTo)
import Text.XML
import Text.XML.Cursor (Cursor)
import qualified Data.IntMap as IM
import qualified Data.Map    as Map
import qualified Data.Set    as Set
import qualified Data.Vector as V

import Codec.Xlsx.Writer.Internal
import Codec.Xlsx.Parser.Internal
import Codec.Xlsx.RichText
import Codec.Xlsx.Types

-- | Shared string table
--
-- A workbook can contain thousands of cells containing string (non-numeric)
-- data. Furthermore this data is very likely to be repeated across many rows or
-- columns. The goal of implementing a single string table that is shared across
-- the workbook is to improve performance in opening and saving the file by only
-- reading and writing the repetitive information once.
--
-- Relevant parts of the EMCA standard (2nd edition, part 1,
-- <http://www.ecma-international.org/publications/standards/Ecma-376.htm>),
-- page numbers refer to the page in the PDF rather than the page number as
-- printed on the page):
--
-- * Section 18.4, "Shared String Table" (p. 1712)
--   in particular subsection 18.4.9, "sst (Shared String Table)" (p. 1726)
--
-- TODO: The @extLst@ child element is currently unsupported.
data SharedStringTable = SharedStringTable {
    _sharedStringTable :: Vector StringItem
  }
  deriving (Show, Eq, Ord)

-- | String Item
--
-- This element is the representation of an individual string in the Shared
-- String table.
--
-- The spec says: "If the string is just a simple string with formatting applied
-- at the cell level, then the String Item (si) should contain a single text
-- element used to express the string. However, if the string in the cell is
-- more complex - i.e., has formatting applied at the character level - then the
-- string item shall consist of multiple rich text runs which collectively are
-- used to express the string.". So we have either a single "Text" field, or
-- else a list of "RichTextRun"s, each of which is some "Text" with layout
-- properties.
--
-- TODO: Currently we do not support @phoneticPr@ (Phonetic Properties, 18.4.3,
-- p. 1723) or @rPh@ (Phonetic Run, 18.4.6, p. 1725).
--
-- Section 18.4.8, "si (String Item)" (p. 1725)
data StringItem =
    StringItemText Text
  | StringItemRich [RichTextRun]
  deriving (Show, Eq, Ord)

{-------------------------------------------------------------------------------
  Lenses
-------------------------------------------------------------------------------}

makeLenses ''SharedStringTable

{-------------------------------------------------------------------------------
  Rendering
-------------------------------------------------------------------------------}

instance ToDocument SharedStringTable where
  toDocument = documentFromElement "Shared string table generated by xlsx"
             . toElement "sst"

-- | See @CT_Sst@, p. 3902.
instance ToElement SharedStringTable where
  toElement nm SharedStringTable{..} = Element {
      elementName       = nm
    , elementAttributes = Map.empty
    , elementNodes      = map (NodeElement . toElement "si")
                        $ V.toList _sharedStringTable
    }

-- | See @CT_Rst@, p. 3903
instance ToElement StringItem where
  toElement nm si = Element {
      elementName       = nm
    , elementAttributes = Map.empty
    , elementNodes      = map NodeElement $
        case si of
          StringItemText text -> [elementContent "t" text]
          StringItemRich rich -> map (toElement "r") rich
    }

{-------------------------------------------------------------------------------
  Parsing
-------------------------------------------------------------------------------}

-- | Parse shared string table
--
-- TODO: This is currently a VERY limited implementation, reusing the old
-- parser for shared string tables. We lose all rich text information. Also,
-- the translation from a list to an IntMap, then back to a list and finally
-- to a vector is also unnecessary. We should just generate a list then and
-- translate directly to a vector.
sstParse :: Cursor -> SharedStringTable
sstParse = aux . parseSharedStrings
  where
    aux :: IntMap Text -> SharedStringTable
    aux = SharedStringTable . V.fromList . map StringItemText . IM.elems

{-------------------------------------------------------------------------------
  Extract shared strings
-------------------------------------------------------------------------------}

-- | Construct the 'SharedStringsTable' from an existing document
sstConstruct :: [Worksheet] -> SharedStringTable
sstConstruct =
    SharedStringTable . V.fromList . uniq . concatMap goSheet
  where
    goSheet :: Worksheet -> [StringItem]
    goSheet = mapMaybe (_cellValue >=> sstEntry) . Map.elems . _wsCells

    sstEntry :: CellValue -> Maybe StringItem
    sstEntry (CellText text) = Just $ StringItemText text
    sstEntry (CellRich rich) = Just $ StringItemRich rich
    sstEntry _               = Nothing

    uniq :: Ord a => [a] -> [a]
    uniq = Set.elems . Set.fromList

sstLookupText :: SharedStringTable -> Text -> Int
sstLookupText sst = sstLookup sst . StringItemText

sstLookupRich :: SharedStringTable -> [RichTextRun] -> Int
sstLookupRich sst = sstLookup sst . StringItemRich

-- | Internal generalization used by 'sstLookupText' and 'sstLookupRich'
--
-- TODO: I don't know why this is using @(>=)@ instead of @(==)@ in the
-- definition (behaviour inherited from the old sst search).
sstLookup :: SharedStringTable -> StringItem -> Int
sstLookup SharedStringTable{_sharedStringTable = shared} si =
    case searchFromTo (\p -> shared V.! p >= si) 0 (V.length shared - 1) of
      Just i  -> i
      Nothing -> error $ "SST entry for " ++ show si ++ " not found"
