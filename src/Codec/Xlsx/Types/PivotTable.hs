{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
module Codec.Xlsx.Types.PivotTable
  ( PivotTable(..)
  , PivotField(..)
  , PivotFieldName(..)
  , PositionedField(..)
  , DataField(..)
  , ConsolidateFunction(..)
  , PivotTableFiles(..)
  , renderPivotTableFiles
  ) where

import Data.Bool (bool)
import Data.ByteString.Lazy (ByteString)
import Data.List (sort)
import Data.List.Extra (nubOrd)
import Data.Maybe (catMaybes)
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Map as M
import Safe (fromJustNote)
import Text.XML

import Codec.Xlsx.Writer.Internal
import Codec.Xlsx.Types.Common
import Codec.Xlsx.Types.RichText

data PivotTable = PivotTable
  { _pvtName :: Text
  , _pvtDataCaption :: Maybe Text
  , _pvtRowFields :: [PositionedField]
  , _pvtColumnFields :: [PositionedField]
  , _pvtDataFields :: [DataField]
  , _pvtFields :: [(PivotFieldName, PivotField)]
  , _pvtRowGrandTotals :: Bool
  , _pvtColumnGrandTotals :: Bool
  , _pvtLocation :: CellRef
  , _pvtSrcSheet :: Text
  , _pvtSrcRef :: Range
  } deriving (Eq, Show)

newtype PivotFieldName =
  PivotFieldName Text
  deriving (Eq, Ord, Show)

data PositionedField
  = DataPosition
  | FieldPosition PivotFieldName
  deriving (Eq, Ord, Show)

data PivotField = PivotField
  { _pvfValues :: [Maybe CellValue]
  } deriving (Eq, Show)

data DataField = DataField
  { _dfField :: PivotFieldName
  , _dfName :: Text
  , _dfFunction :: ConsolidateFunction
  } deriving (Eq, Show)

-- | Data consolidation functions specified by the user and used to
-- consolidate ranges of data
--
-- See 18.18.17 "ST_DataConsolidateFunction (Data Consolidation
-- Functions)" (p.  2447)
data ConsolidateFunction
  = ConsolidateAverage
    -- ^ The average of the values.
  | ConsolidateCount
    -- ^ The number of data values. The Count consolidation function
    -- works the same as the COUNTA worksheet function.
  | ConsolidateCountNums
    -- ^ The number of data values that are numbers. The Count Nums
    -- consolidation function works the same as the COUNT worksheet
    -- function.
  | ConsolidateMaximum
    -- ^ The largest value.
  | ConsolidateMinimum
    -- ^ The smallest value.
  | ConsolidateProduct
    -- ^ The product of the values.
  | ConsolidateStdDev
    -- ^ An estimate of the standard deviation of a population, where
    -- the sample is a subset of the entire population.
  | ConsolidateStdDevP
    -- ^ The standard deviation of a population, where the population
    -- is all of the data to be summarized.
  | ConsolidateSum
    -- ^ The sum of the values.
  | ConsolidateVariance
    -- ^ An estimate of the variance of a population, where the sample
    -- is a subset of the entire population.
  | ConsolidateVarP
    -- ^ The variance of a population, where the population is all of
    -- the data to be summarized.
  deriving (Eq, Show)

data CacheDefinition = CacheDefinition
  { cdSourceRef :: CellRef
  , cdSourceSheet :: Text
  , cdFields :: [CacheField]
  } deriving (Eq, Show)

data CacheField = CacheField
  { cfName :: Text
  , cfContainsMixedTypes :: Bool
  , cfContainsNumber :: Bool
  , cfContainsSemiMixedTypes :: Bool
  , cfContainsString :: Bool
  , cfValues :: [Maybe CellValue]
  } deriving (Eq, Show)

{-------------------------------------------------------------------------------
  Rendering
-------------------------------------------------------------------------------}

data PivotTableFiles = PivotTableFiles
  { pvtfTable :: ByteString
  , pvtfCacheDefinition :: ByteString
  } deriving (Eq, Show)

renderPivotTableFiles :: Int -> PivotTable -> PivotTableFiles
renderPivotTableFiles cacheId t = PivotTableFiles {..}
  where
    pvtfTable =
      renderLBS def $ ptDefinitionDocument cacheId t (cdFields cacheDefinition)
    cacheDefinition = generateCache t
    pvtfCacheDefinition = renderLBS def $ toDocument cacheDefinition

ptDefinitionDocument :: Int -> PivotTable -> [CacheField] -> Document
ptDefinitionDocument cacheId t =
    documentFromElement "Pivot table generated by xlsx" .
    ptDefinitionElement "pivotTableDefinition" cacheId t

ptDefinitionElement :: Name -> Int -> PivotTable -> [CacheField] -> Element
ptDefinitionElement nm cacheId PivotTable {..} cFields =
  elementList nm attrs elements
  where
    attrs =
      catMaybes
        [ "dataCaption" .=? _pvtDataCaption
        , "colGrandTotals" .=? justFalse _pvtColumnGrandTotals
        , "rowGrandTotals" .=? justFalse _pvtRowGrandTotals
        ] ++
      [ "name" .= _pvtName
      , "cacheId" .= cacheId
      , "dataOnRows" .= (DataPosition `elem` _pvtRowFields)
      ]
    elements = [location, pivotFields, rowFields, colFields, dataFields]
    location =
      leafElement
        "location"
        [ "ref" .= _pvtLocation
          -- TODO : set proper
        , "firstHeaderRow" .= (1 :: Int)
        , "firstDataRow" .= (2 :: Int)
        , "firstDataCol" .= (1 :: Int)
        ]
    fieldNames = map fst _pvtFields
    name2x = M.fromList $ zip fieldNames [0 ..]
    mapFieldToX f = fromJustNote "no field" $ M.lookup f name2x
    pivotFields =
      elementListSimple "pivotFields" . map pFieldEl $ zip fieldNames cFields
    pFieldEl (fName, CacheField {..})
      | FieldPosition fName `elem` _pvtRowFields =
        pFieldElWithItems fName ("axisRow" :: Text) (length cfValues)
      | FieldPosition fName `elem` _pvtColumnFields =
        pFieldElWithItems fName ("axisCol" :: Text) (length cfValues)
      | otherwise =
        leafElement
          "pivotField"
          [ "name" .= fName
          , "dataField" .= True
          , "showAll" .= False
          , "outline" .= False
          ]
    pFieldElWithItems fName axis n =
      elementList
        "pivotField"
        [ "name" .= fName
        , "axis" .= axis
        , "showAll" .= False
        , "outline" .= False
        ] .
      replicate 1 . elementListSimple "items" $
      map (\x -> leafElement "item" ["x" .= x]) [0 .. (n - 1)] ++
      [leafElement "item" ["t" .= ("default" :: Text)]]
    rowFields =
      elementListSimple "rowFields" . map fieldEl $
      if length _pvtDataFields > 1
        then _pvtRowFields
        else filter (/= DataPosition) _pvtRowFields
    colFields = elementListSimple "colFields" $ map fieldEl _pvtColumnFields
    fieldEl p = leafElement "field" ["x" .= fieldPos p]
    fieldPos DataPosition = (-2) :: Int
    fieldPos (FieldPosition f) = mapFieldToX f
    dataFields = elementListSimple "dataFields" $ map dFieldEl _pvtDataFields
    dFieldEl DataField {..} =
      leafElement "dataField" $
      catMaybes
        [ "name" .=? Just _dfName
        , "fld" .=? Just (mapFieldToX _dfField)
        , "subtotal" .=? justNonDef ConsolidateSum _dfFunction
        ]

instance ToAttrVal ConsolidateFunction where
  toAttrVal ConsolidateAverage = "average"
  toAttrVal ConsolidateCount = "count"
  toAttrVal ConsolidateCountNums = "countNums"
  toAttrVal ConsolidateMaximum = "max"
  toAttrVal ConsolidateMinimum = "min"
  toAttrVal ConsolidateProduct = "product"
  toAttrVal ConsolidateStdDev = "stdDev"
  toAttrVal ConsolidateStdDevP = "stdDevp"
  toAttrVal ConsolidateSum = "sum"
  toAttrVal ConsolidateVariance = "var"
  toAttrVal ConsolidateVarP = "varp"

instance ToAttrVal PivotFieldName where
  toAttrVal (PivotFieldName n) = toAttrVal n

generateCache :: PivotTable -> CacheDefinition
generateCache PivotTable {..} =
  CacheDefinition
  { cdSourceRef = _pvtSrcRef
  , cdSourceSheet = _pvtSrcSheet
  , cdFields = cachedFields
  }
  where
    cachedFields = map cache _pvtFields
    cache (PivotFieldName name, PivotField {..}) =
      let values = nubOrd $ sort _pvfValues
          string = any (maybe False hasString) values
          number = any (maybe False hasNumber) values
          mixed = string && number -- what about blanks?
      in CacheField
         { cfName = name
         , cfValues = values
         , cfContainsNumber = number
         , cfContainsString = string
         , cfContainsMixedTypes = mixed
         , cfContainsSemiMixedTypes = string
         }
    hasString (CellText _) = True
    hasString (CellRich _) = True
    hasString _ = False
    hasNumber (CellBool _) = True
    hasNumber (CellDouble _) = True
    hasNumber _ = False

instance ToDocument CacheDefinition where
  toDocument =
    documentFromElement "Pivot cache definition generated by xlsx" .
    toElement "pivotCacheDefinition"

instance ToElement CacheDefinition where
 toElement nm CacheDefinition {..} = elementList nm attrs elements
  where
    attrs = ["invalid" .= True, "refreshOnLoad" .= True]
    elements = [worksheetSource, cacheFields]
    worksheetSource =
      elementList
        "cacheSource"
        ["type" .= ("worksheet" :: Text)]
        [ leafElement
            "worksheetSource"
            ["ref" .= cdSourceRef, "sheet" .= cdSourceSheet]
        ]
    cacheFields =
      elementListSimple "cacheFields" $ map (toElement "cacheField") cdFields

instance ToElement CacheField where
  toElement nm CacheField {..} = elementList nm attrs [sharedItems]
    where
      attrs = ["name" .= cfName]
      sharedItems =
        elementList
          "sharedItems" sharedAttrs
          (map toShared cfValues)
      sharedAttrs = catMaybes
          [ "containsMixedTypes" .=? justTrue cfContainsMixedTypes
          , "containsNumber" .=? justTrue cfContainsNumber
          , "containsSemiMixedTypes" .=? justFalse cfContainsString
          , "containsString" .=? justFalse cfContainsString
          ]
      toShared = maybe (emptyElement "m") toShared'
      toShared' (CellText txt) = leafElement "s" ["v" .= txt]
      toShared' (CellRich rich) = leafElement "s" ["v" .= rich2txt rich]
      toShared' (CellDouble d) = leafElement "n" ["v" .= txtd d]
      toShared' (CellBool b) = leafElement "n" ["v" .= bool (0::Int) 1 b]
      rich2txt = T.concat . map _richTextRunText
